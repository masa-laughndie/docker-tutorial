# メモ

## Part 1： 概要説明とセットアップ

### コンテナとは

* マシン上でサンドボックス化したプロセスであり、ホストマシン上にある他すべてのプロセスから隔離されている => プロセス群の周辺に壁を設ける技術
  * 隔離の方法( = 壁の作り方)
    * Linuxカーネルの「名前空間」と「cgroups」という機能を利用する活用している
      * 名前空間(namespaces) ... コンテナを１つの仮想マシンのように占有されたシステムとして見せる。ある名前空間内のプロセスは他の名前空間内のプロセスとリソースが隔離されて、プロセスごとの環境が構築可能になる。
        * => プロセス間内で何が(ソフトウェア的に)見えるかを制限
        * namespaceで隔離できるリソース
          * UID((ユーザーID)/GID(グループID) ... 異なる名前空間で同じUIDのユーザーを作成できる
          * PID(プロセスID) ... 異なる名前空間で同じPIDのユーザーを作成できる
          * ネットワークスタック ... ネットワークデバイス、IPアドレス、ルーティングテーブル...
          * IPC(プロセス間通信) ... IPCオブジェクト、メッセージキュー...
          * マウントポイント ... 異なる名前空間のファイルシステムにアクセスできないようにする
          * ホスト/ドメイン名
      * cgroups(コントロールグループ) ... コンテナ内からアクセス可能なシステムのリソース(CPUやメモリなど)を厳密に制限する
        * => プロセスグループが(ハードウェア的に)どれだけ利用できるかを制限
* 実行可能なイメージの実体(インスタンス)

(ref)

* https://www.undercoverlog.com/entry/2018/10/01/Docker%E3%81%AE%E5%8B%95%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88%E5%90%8D%E5%89%8D%E7%A9%BA%E9%96%93/cgroups%EF%BC%89

### コンテナ：イメージとは

* コンテナのテンプレート
* コンテナ内で実行するアプリケーションに必要なコマンドやメタデータが含まれている

## Part 2: サンプル・アプリケーション

### コンテナイメージの構築(build)

* Dockerfile ... コンテナイメージの作成で使うコマンドが書かれたスクリプト
* `docker build -t getting-started .`
  * `docker build` ... イメージの構築コマンド
  * `-t getting-started` ... イメージのリポジトリ名。repository_name:tag という感じでタグ付けできる、おそらくデフォルトのタグは latest
  * `.` ... Dockerfile のパス指定

### コンテナの起動

* `docker run -dp 3011:3011 getting-started`
  * `docker run getting-started` ... 指定したイメージをもとにコンテナを起動するコマンド
  * `-d` ... バックグランド起動
  * `-p 3011:3011` ... ポートマッピング設定。ホストのポート番号:コンテナのポート番号

(ref)

* https://qiita.com/keitean/items/6475f969591fc67d3957

## Part 3: アプリケーションの更新

### ソースコードの変更

* ソースコードを変更してイメージを更新する際は再度 `docker build -t getting-started .` をすることで上書きされる。

### 古いコンテナを置き換える

* 古いコンテナで起動しっぱなしのまま、同じポートで起動しようとすると空きがなくて起動できない
* イメージの更新をしたら、コンテナを一度削除して再度起動する。
  1. `docker ps`  ... コンテナIDを確認
  2. `docker stop <コンテナID>` ... コンテナ停止(memo: `docker restart` ... コンテナ再起動)
  3. `docker rm <コンテナID>` ... コンテナ削除
  4. `docker run -dp 3011:3011 getting-started` ... コンテナ起動

## Part 4: アプリケーションの共有

* 構築したDockerイメージはDockerレジストリで共有できる。
* デフォルトのレジストリはDocker Hub

### イメージを送信

* リポジトリ名の変更手順
  1. `docker login -u <ユーザー名>` + パスワード入力 ... docker hub にログイン
  2. `docker tag <ローカルに存在するリネームしたいリポジトリ> <リネーム後のリポジトリ名>` ... リポジトリ名の変更
* イメージの送信
  1. [docker hub サイト](https://hub.docker.com/)にログイン
  2. 「create repository」からリポジトリを作成
  3. `docker login ...`
  4. `docker push <リポジトリ名>`

## Part 5: DBの保持

### コンテナのファイルシステム

* 同じイメージで作成したコンテナでもお互いが隔離されたプロセス上に存在しているので一方から他方の中のファイルを参照することはできない
* `docker run --name <コンテナ名>` ... コンテナに名前をつけられる。この名前はコンテナIDの代わりとしてコマンド内で使える
* `docker exec <コンテナIDorコンテナ名> <実行コマンド>` ... コンテナ内でのコマンド実行

### コンテナのボリューム

* ボリュームとは
  * Dickerコンテナにおいて生成され利用されるデータを永続的に保持する目的で利用される仕組み
  * コンテナ内で指定したファイルシステムのパスをホストマシン上へと接続できる機能を備えている
    * コンテナ内の特定のディレクトリをホストのディレクトリにマウントするとディレクトリに対する変更をホストマシン上から見ることができる
    * 同じディレクトリにマウントすれば、コンテナの再起動後も同じファイルが見える
* ボリュームの種類
  * 名前付きボリューム(named volume)
  * バインドマウント(bind mount)

### todoデータの保持(名前付きボリューム)

* ボリュームを作成し、データを保管するディレクトリに取り付ける(マウントする)とデータを保持できる
* 名前付きボリューム
  * 単なるデータの入れ物
  * Docker がディスク上で物理的な場所を確保する
  * そのボリュームに名前をつけておけば良いだけ

* ボリュームの利用手順
  1. `docker volume create <ボリューム名>` ... ボリュームの作成
  2. `docker run -dp 3000:3000 -v todo-db:/etc/todos getting-started` ... ボリュームのマウント指定
    * `-v <ボリューム名>:<コンテナ内の保持したいディレクトリパス(マウント先)>`
  3. これで再起動しても前の状態が保持される

### ボリュームを深掘り

* マウントされるボリュームの実際のホスト上における保存先
  * `docker volume inpsect <ボリューム名>` からの「Mountpoint」が保存先(root権限じゃないと確認はできない。)

## Part 6: バインドマウントの使用

* バインドマウントとは
  * ボリュームとの共通点
    * `-v` で指定する
    * 変更を永続化するもの
  * ボリュームとの相違点
    * ボリュームはホスト上に新しく保存先ディレクトリを作成する(Dockerが管理)
      * ex: `-v my-volume:/path/to/container_file`
    * バインドマウントはホスト上の既存に存在するディレクトリ(保存したい場所)を直接指定する(自身で管理)
      * ex: `-v /path/to/host_file:/path/to/container_file`
  * 名前付きボリュームと同様に `-v` で指定できるが、ホスト上の保存したい場所を直接指定するのが名前付きボリュームとの違い
  * バインドマウントを利用すると「ホストマシン」上のファイルやディレクトリがコンテナ内にマウントされる

![figure1](https://matsuand.github.io/docs.docker.jp.onthefly/storage/images/types-of-mounts-bind.png)

### 開発モードのコンテナを起動

* `docker run -dp 3000:3000 -w /app -v "$(pwd):/app" node:12-alpine sh -c "yarn install && yarn run dev"`
  * `-w /app` ... コマンドを実行する場所としての作業(working)ディレクトリを指定
* `docker logs -f <コンテナID or コンテナ名>`
  * `docker logs` ... docker コマンドのログを閲覧できる
  * `-f` ... ログをフォローして出力する(tail -f とかと同様)

## Part 7: 複数コンテナのアプリ

* 基本的に１つのコンテナでは１つのことをすべき
  * スケールしやすくなる
  * バージョンの更新などで影響を限定的にできる
  * ...

### コンテナのネットワーク機能

* ネットワーク機能(networking)とは
  * デフォルトでは孤立状態のコンテナ同士を通信できるようにする
  * 同じネットワークにあるコンテナ同士が通信できる

### Mysqlの起動

* `docker network create <ネットワーク名>` ... ネットワークの作成

* mysqlDBの起動
  * `docker run -d --network todo-app --network-alias mysql -v todo-mysql-data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=secret -e MYSQL_DATABASE=todos --name todo-mysql --platform linux/amd64 mysql:5.7`
    * `--network todo-app` ... 接続するネットワークの指定
    * `--network-alias mysql` ... ネットワーク内での別名の指定
    * `-e ...` ... 環境変数の設定
    * `docker run` コマンドでは事前に volume を作成していなくても自動的に作成してくれる
* アプリの起動
  * `docker run -dp 3011:3011 -w /app -v "$(pwd):/app" --network todo-app -e MYSQL_HOST=mysql -e MYSQL_USER=root -e MYSQL_PASSWORD=secret -e MYSQL_DB=todos --name todo node:12-alpine sh -c "apk add --no-cache python2 g++ make && yarn install && yarn run dev"`

=> network に同じものを指定すると独立したコンテナ同士で接続が可能となる

## Part 9: Docker Compose を使う

* Docker Compose とは
  * 複数コンテナのアプリケーションの定義や実行をするためのツール
  * YAMLファイルを使ってアプリケーションサービスの設定を行う

### Compose ファイルの作成

* 基本的には作業ディレクトリのルートに `docker-compose.yml` を作成してそこに記述していく
* 細かいところは `docker-compose.yml` にコメント残している
* ネットワーク設定

### アプリケーションスタックの実行

* `docker-compose up -d` (@設定ファイルがあるルートディレクトにて)
  * `docker-compose up` ... docker compose 実行コマンド
  + `-d` ... バックグランド実行
* `docker-compose logs -f` ... ログ出力 & 追従

* Dockerダッシュボードではデフォルトでは `docker-compose.yml` が置かれているディレクトリ名がプロジェクト名として指定される
* Dockerダッシュボードのプロジェクト内には定義したコンテナが存在し、デフォルトでは `<プロジェクト名>_<サービス名>_<レプリカ数>` になっている

### 全てを解体

* `docker-compose down` ... コンテナの終了&削除(ネットワークも削除される)
  * `--volumes` ... ボリュームも一緒に削除

## Part 10: イメージ構築のベストプラクティス

### 安全性の検査

* `docker scan <イメージ名>` ... イメージの脆弱性を検知できる
  * 事前に `docker scan --login` でログインが必要
  * Docker は脆弱性検査サービスを提供する Snyk と提携している

### イメージの階層化

* `docker image history <イメージ名>` ... イメージのレイヤーごとのコマンドを確認できる
  * `--no-trunc` ... 内容を省力せずに表示できる

### レイヤーのキャッシュ

* あるレイヤーのコマンドを変更すると以降のレイヤーは再作成される
* つまり、ある修正したコマンド(レイヤー)以降にライブラリのインストール処理(ex: `yarn install`)などがあると再度最初から依存関係の確認などが実行される
* これを回避するためにインストール処理の前に事前に `COPY` を使って依存関係関連の処理などを持ってくると良い
  * イメージの再構築には時間がかかるが、それ以降依存関係関連の変更がない場合はログ上に `Using cache` と表示されて処理がスキップされ構築が早くなる
* `.dockerignore` ファイルにコピーしたくないディレクトリ等を記述しておくとコピーを除外してくれる